
import asyncio
import random
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from telegram.constants import ParseMode
from telegram.error import RetryAfter, TimedOut

# Importar db del m√≥dulo principal
from telegram_bot import db

class GateSystem:
    def __init__(self, db):
        self.db = db
        self.active_sessions = {}  # Sesiones activas de gates
        self.rate_limit_tracker = {}  # Control de rate limiting

    def is_authorized(self, user_id: str) -> bool:
        """Verificar si el usuario tiene acceso (fundador nivel 1, co-fundador o premium)"""
        # Verificar si es fundador nivel 1
        if self.db.is_founder(user_id):
            return True

        # Verificar si es co-fundador (nivel 2)
        staff_data = self.db.get_staff_role(user_id)
        if staff_data and staff_data['role'] == '2':
            return True

        # Verificar si es premium activo
        user_data = self.db.get_user(user_id)
        if user_data.get('premium', False):
            premium_until = user_data.get('premium_until')
            if premium_until:
                premium_date = datetime.fromisoformat(premium_until)
                if datetime.now() < premium_date:
                    return True
        return False

    def create_gates_menu(self) -> InlineKeyboardMarkup:
        """Crear men√∫ principal de gates"""
        keyboard = [
            [
                InlineKeyboardButton("üîµ Stripe Gate", callback_data='gate_stripe'),
                InlineKeyboardButton("üü† Amazon Gate", callback_data='gate_amazon')
            ],
            [
                InlineKeyboardButton("üî¥ PayPal Gate", callback_data='gate_paypal'),
                InlineKeyboardButton("üü° Ayden Gate", callback_data='gate_ayden')
            ],
            [
                InlineKeyboardButton("üü¢ Auth Gate", callback_data='gate_auth'),
                InlineKeyboardButton("‚ö´ CCN Charge", callback_data='gate_ccn')
            ],
            [
                InlineKeyboardButton("üìä Gate Status", callback_data='gates_status'),
                InlineKeyboardButton("‚ùå Cerrar", callback_data='gates_close')
            ]
        ]
        return InlineKeyboardMarkup(keyboard)

    async def process_stripe_gate(self, card_data: str) -> dict:
        """Procesar verificaci√≥n Stripe Gate - EFECTIVIDAD REALISTA"""
        await asyncio.sleep(random.uniform(2.0, 4.0))

        parts = card_data.split('|')
        if len(parts) < 4:
            return {
                'success': False,
                'message': '‚ùå Formato inv√°lido - Use: 4532123456781234|12|25|123',
                'status': 'DEAD'
            }

        card_number = parts[0]
        exp_month = parts[1]
        exp_year = parts[2]
        cvv = parts[3]

        # ALGORITMO REALISTA PARA STRIPE (15-25% m√°ximo)
        success_rate = 0.08  # 8% base REALISTA

        # An√°lisis del BIN (bonificaciones MENORES)
        premium_bins = ['4532', '4485', '5531', '4539']
        if any(card_number.startswith(bin_) for bin_ in premium_bins):
            success_rate += 0.04  # +4% m√°ximo
        elif card_number.startswith(('40', '41', '51', '52')):
            success_rate += 0.02  # +2%

        # An√°lisis CVV (bonificaci√≥n M√çNIMA)
        if cvv.endswith(('7', '3', '9')):
            success_rate += 0.01  # +1%

        # Factor de aleatoriedad realista
        success_rate *= random.uniform(0.6, 1.4)
        
        # M√ÅXIMO REALISTA del 25%
        success_rate = min(success_rate, 0.25)

        is_success = random.random() < success_rate

        if is_success:
            responses = [
                "‚úÖ Payment successful - $1.00 charged",
                "‚úÖ Transaction approved - CVV2 Match",
                "‚úÖ Stripe: authorized - Gateway Response: 00",
                "‚úÖ Card charged successfully - Risk: Low"
            ]
            return {
                'success': True,
                'message': random.choice(responses),
                'status': 'LIVE',
                'gateway': 'Stripe Ultra',
                'amount': '$1.00'
            }
        else:
            responses = [
                "‚ùå Card declined - Insufficient funds",
                "‚ùå Transaction failed - Invalid CVV",
                "‚ùå Payment declined - Do not honor",
                "‚ùå Risk threshold exceeded",
                "‚ùå Generic decline - Contact bank",
                "‚ùå Card blocked - Security"
            ]
            return {
                'success': False,
                'message': random.choice(responses),
                'status': 'DEAD',
                'gateway': 'Stripe Ultra',
                'amount': '$0.00'
            }

    async def process_amazon_gate(self, card_data: str) -> dict:
        """Procesar verificaci√≥n Amazon Gate - EFECTIVIDAD REALISTA"""
        await asyncio.sleep(random.uniform(3.0, 5.0))

        parts = card_data.split('|')
        if len(parts) < 4:
            return {
                'success': False,
                'message': '‚ùå Formato inv√°lido',
                'status': 'DEAD'
            }

        # Amazon es ULTRA restrictivo - 8-18% m√°ximo
        success_rate = 0.05  # 5% base REALISTA

        card_number = parts[0]
        if card_number.startswith('4'):
            success_rate += 0.03  # Amazon prefiere Visa (+3%)
        elif card_number.startswith('5'):
            success_rate += 0.02  # MasterCard (+2%)

        # Factor de aleatoriedad
        success_rate *= random.uniform(0.4, 1.6)
        
        # M√ÅXIMO REALISTA del 18%
        success_rate = min(success_rate, 0.18)

        is_success = random.random() < success_rate

        if is_success:
            responses = [
                "‚úÖ Amazon: Payment method added successfully",
                "‚úÖ Amazon: Card verified for purchases",
                "‚úÖ Amazon: Billing updated - Ready for orders"
            ]
            return {
                'success': True,
                'message': random.choice(responses),
                'status': 'LIVE',
                'gateway': 'Amazon Prime',
                'amount': '$0.00'
            }
        else:
            responses = [
                "‚ùå Amazon: Invalid payment method",
                "‚ùå Amazon: Card verification failed",
                "‚ùå Amazon: Unable to add card",
                "‚ùå Amazon: Billing address mismatch",
                "‚ùå Amazon: Security review required"
            ]
            return {
                'success': False,
                'message': random.choice(responses),
                'status': 'DEAD',
                'gateway': 'Amazon Prime',
                'amount': '$0.00'
            }

    async def process_paypal_gate(self, card_data: str) -> dict:
        """Procesar verificaci√≥n PayPal Gate - EFECTIVIDAD REALISTA"""
        await asyncio.sleep(random.uniform(2.5, 4.5))

        # PayPal efectividad ULTRA REALISTA (10-20% m√°ximo)
        success_rate = 0.06  # 6% base realista
        
        # Factor de aleatoriedad
        success_rate *= random.uniform(0.3, 1.7)
        
        # M√ÅXIMO REALISTA del 20%
        success_rate = min(success_rate, 0.20)

        is_success = random.random() < success_rate

        if is_success:
            return {
                'success': True,
                'message': "‚úÖ PayPal: Card linked successfully",
                'status': 'LIVE',
                'gateway': 'PayPal Express',
                'amount': '$0.00'
            }
        else:
            responses = [
                "‚ùå PayPal: Card verification failed",
                "‚ùå PayPal: Unable to link card",
                "‚ùå PayPal: Security check failed",
                "‚ùå PayPal: Invalid card data"
            ]
            return {
                'success': False,
                'message': random.choice(responses),
                'status': 'DEAD',
                'gateway': 'PayPal Express',
                'amount': '$0.00'
            }

    async def process_ayden_gate(self, card_data: str) -> dict:
        """Procesar verificaci√≥n Ayden Gate - EFECTIVIDAD REALISTA"""
        await asyncio.sleep(random.uniform(3.5, 5.5))

        parts = card_data.split('|')
        if len(parts) < 4:
            return {
                'success': False,
                'message': '‚ùå Formato inv√°lido',
                'status': 'DEAD'
            }

        # Ayden es muy restrictivo - 5-15% m√°ximo
        success_rate = 0.03  # 3% base ULTRA realista

        card_number = parts[0]
        # Ayden prefiere ciertos BINs europeos
        if card_number.startswith(('4000', '4001', '5200', '5201')):
            success_rate += 0.02  # +2%

        # Factor de aleatoriedad
        success_rate *= random.uniform(0.2, 2.0)
        
        # M√ÅXIMO REALISTA del 15%
        success_rate = min(success_rate, 0.15)

        is_success = random.random() < success_rate

        if is_success:
            responses = [
                "‚úÖ Ayden: Payment authorized successfully",
                "‚úÖ Ayden: Card verification passed",
                "‚úÖ Ayden: Transaction approved - EU gateway"
            ]
            return {
                'success': True,
                'message': random.choice(responses),
                'status': 'LIVE',
                'gateway': 'Ayden EU',
                'amount': '$0.00'
            }
        else:
            responses = [
                "‚ùå Ayden: Authorization declined",
                "‚ùå Ayden: Card not supported",
                "‚ùå Ayden: Risk score too high",
                "‚ùå Ayden: 3DS authentication failed"
            ]
            return {
                'success': False,
                'message': random.choice(responses),
                'status': 'DEAD',
                'gateway': 'Ayden EU',
                'amount': '$0.00'
            }

    async def process_auth_gate(self, card_data: str) -> dict:
        """Procesar verificaci√≥n Auth Gate - EFECTIVIDAD REALISTA"""
        await asyncio.sleep(random.uniform(1.5, 3.0))

        # Auth Gate efectividad ULTRA REALISTA (8-16% m√°ximo)
        success_rate = 0.04  # 4% base realista
        
        # Factor de aleatoriedad
        success_rate *= random.uniform(0.5, 2.0)
        
        # M√ÅXIMO REALISTA del 16%
        success_rate = min(success_rate, 0.16)

        is_success = random.random() < success_rate

        if is_success:
            return {
                'success': True,
                'message': "‚úÖ Auth: Verification successful",
                'status': 'LIVE',
                'gateway': 'Auth Check',
                'amount': '$0.00'
            }
        else:
            responses = [
                "‚ùå Auth: Verification failed",
                "‚ùå Auth: Invalid card data",
                "‚ùå Auth: CVV check failed"
            ]
            return {
                'success': False,
                'message': random.choice(responses),
                'status': 'DEAD',
                'gateway': 'Auth Check',
                'amount': '$0.00'
            }

    async def process_ccn_charge(self, card_data: str) -> dict:
        """Procesar CCN Charge Gate - EFECTIVIDAD REALISTA"""
        await asyncio.sleep(random.uniform(2.0, 4.0))

        parts = card_data.split('|')
        if len(parts) < 4:
            return {
                'success': False,
                'message': '‚ùå Formato inv√°lido',
                'status': 'DEAD'
            }

        # CCN Charge efectividad REALISTA (12-22% m√°ximo)
        success_rate = 0.07  # 7% base realista

        card_number = parts[0]
        # CCN prefiere ciertos tipos de tarjeta
        if card_number.startswith(('4111', '4242', '5555')):
            success_rate += 0.03  # +3%

        # Factor de aleatoriedad
        success_rate *= random.uniform(0.6, 1.8)
        
        # M√ÅXIMO REALISTA del 22%
        success_rate = min(success_rate, 0.22)

        is_success = random.random() < success_rate

        if is_success:
            responses = [
                "‚úÖ CCN: Charge successful - $0.50",
                "‚úÖ CCN: Payment processed - CVV verified",
                "‚úÖ CCN: Transaction approved - Low risk"
            ]
            return {
                'success': True,
                'message': random.choice(responses),
                'status': 'LIVE',
                'gateway': 'CCN Charge',
                'amount': '$0.50'
            }
        else:
            responses = [
                "‚ùå CCN: Charge declined - Insufficient funds",
                "‚ùå CCN: Payment failed - Invalid card",
                "‚ùå CCN: Transaction denied - Bank decline",
                "‚ùå CCN: Risk threshold exceeded"
            ]
            return {
                'success': False,
                'message': random.choice(responses),
                'status': 'DEAD',
                'gateway': 'CCN Charge',
                'amount': '$0.00'
            }

    async def safe_edit_message(self, message, text, reply_markup=None, parse_mode=ParseMode.MARKDOWN):
        """Editar mensaje de forma segura con control de rate limiting"""
        try:
            await message.edit_text(text, reply_markup=reply_markup, parse_mode=parse_mode)
        except RetryAfter as e:
            # Esperar el tiempo requerido por Telegram
            await asyncio.sleep(e.retry_after + 1)
            try:
                await message.edit_text(text, reply_markup=reply_markup, parse_mode=parse_mode)
            except Exception:
                # Si falla de nuevo, enviar nuevo mensaje
                await message.reply_text(text, reply_markup=reply_markup, parse_mode=parse_mode)
        except TimedOut:
            await asyncio.sleep(2)
            try:
                await message.edit_text(text, reply_markup=reply_markup, parse_mode=parse_mode)
            except Exception:
                await message.reply_text(text, reply_markup=reply_markup, parse_mode=parse_mode)
        except Exception:
            # Como √∫ltimo recurso, enviar nuevo mensaje
            await message.reply_text(text, reply_markup=reply_markup, parse_mode=parse_mode)

# Instancia global del sistema de gates
gate_system = None

async def gates_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando principal /gates - Todos pueden ver, solo premium/fundadores pueden usar"""
    global gate_system
    if gate_system is None:
        gate_system = GateSystem(db)

    user_id = str(update.effective_user.id)

    # Verificar cr√©ditos (5 cr√©ditos por uso)
    user_data = db.get_user(user_id)
    if user_data['credits'] < 5:
        await update.message.reply_text(
            "‚ùå **CR√âDITOS INSUFICIENTES** ‚ùå\n\n"
            f"üí∞ **Necesitas:** 5 cr√©ditos\n"
            f"üí≥ **Tienes:** {user_data['credits']} cr√©ditos\n\n"
            "üéÅ **Obtener m√°s cr√©ditos:**\n"
            "‚Ä¢ `/bonus` - Bono diario gratis\n"
            "‚Ä¢ `/juegos` - Casino bot\n"
            "‚Ä¢ Contactar administraci√≥n",
            parse_mode=ParseMode.MARKDOWN
        )
        return

    # Crear men√∫ de gates
    keyboard = gate_system.create_gates_menu()

    # Determinar tipo de usuario y acceso
    is_founder = db.is_founder(user_id)
    staff_data = db.get_staff_role(user_id)
    is_cofounder = staff_data and staff_data['role'] == '2'
    is_authorized = gate_system.is_authorized(user_id)
    
    if is_authorized:
        if is_founder:
            user_type = "üëë FUNDADOR"
            efectividad_text = "8-25% (Realista Pro)"
        elif is_cofounder:
            user_type = "üíé CO-FUNDADOR"
            efectividad_text = "8-25% (Realista Pro)"
        else:
            user_type = "üíé PREMIUM"
            efectividad_text = "8-25% (Realista)"
        access_text = "‚úÖ ACCESO COMPLETO"
    else:
        user_type = "üÜì USUARIO EST√ÅNDAR"
        access_text = "‚ùå SOLO VISTA PREVIA"
        efectividad_text = "Requiere Premium"

    response = f"üî• **GATES SYSTEM ULTRA** üî•\n"
    response += f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n"
    response += f"üéØ **Usuario:** {user_type}\n"
    response += f"üîê **Estado:** {access_text}\n"
    response += f"üí∞ **Cr√©ditos:** {user_data['credits']}\n"
    response += f"üí≥ **Costo por gate:** 5 cr√©ditos\n"
    response += f"‚ö° **Efectividad:** {efectividad_text}\n\n"
    
    if not is_authorized:
        response += f"üö´ **AVISO:** Solo usuarios Premium, Fundadores y Co-Fundadores pueden procesar tarjetas\n"
        response += f"üëÄ **Puedes explorar el men√∫ pero no usar las funciones**\n\n"
    
    response += f"üåü **GATES DISPONIBLES:**\n"
    response += f"üîµ **Stripe Gate** - Pagos premium (8-25%)\n"
    response += f"üü† **Amazon Gate** - E-commerce (5-18%)\n"
    response += f"üî¥ **PayPal Gate** - Wallet validation (6-20%)\n"
    response += f"üü° **Ayden Gate** - Procesador EU (3-15%)\n"
    response += f"üü¢ **Auth Gate** - Autorizaci√≥n (4-16%)\n"
    response += f"‚ö´ **CCN Charge** - Cargo directo (7-22%)\n\n"
    
    if is_authorized:
        response += f"üí° **Selecciona el gate que deseas usar:**"
    else:
        response += f"üíé **¬°Obt√©n Premium para acceso completo!**"

    await update.message.reply_text(
        response,
        reply_markup=keyboard,
        parse_mode=ParseMode.MARKDOWN
    )

async def handle_gate_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Manejar callbacks de gates"""
    global gate_system
    query = update.callback_query
    user_id = str(query.from_user.id)

    await query.answer()

    if query.data == 'gates_close':
        await query.edit_message_text(
            "‚ùå **Gates System cerrado**\n\n"
            "üí° Usa `/gates` para acceder nuevamente",
            parse_mode=ParseMode.MARKDOWN
        )
        return

    if query.data == 'gates_status':
        status_text = f"üìä **ESTADO DE GATES** üìä\n\n"
        status_text += f"üîµ **Stripe Gate:** üü¢ Online (8-25% efectividad)\n"
        status_text += f"üü† **Amazon Gate:** üü¢ Online (5-18% efectividad)\n"
        status_text += f"üî¥ **PayPal Gate:** üü¢ Online (6-20% efectividad)\n"
        status_text += f"üü° **Ayden Gate:** üü¢ Online (3-15% efectividad)\n"
        status_text += f"üü¢ **Auth Gate:** üü¢ Online (4-16% efectividad)\n"
        status_text += f"‚ö´ **CCN Charge:** üü¢ Online (7-22% efectividad)\n\n"
        status_text += f"‚è∞ **√öltima actualizaci√≥n:** {datetime.now().strftime('%H:%M:%S')}\n"
        status_text += f"üîÑ **Uptime:** 99.9%\n"
        status_text += f"‚ö†Ô∏è **Efectividad REALISTA para usuarios de pago**"

        back_keyboard = [[InlineKeyboardButton("üîô Volver", callback_data='gates_back')]]
        await query.edit_message_text(
            status_text,
            reply_markup=InlineKeyboardMarkup(back_keyboard),
            parse_mode=ParseMode.MARKDOWN
        )
        return

    if query.data == 'gates_back':
        keyboard = gate_system.create_gates_menu()
        user_data = db.get_user(user_id)
        is_founder = db.is_founder(user_id)
        staff_data = db.get_staff_role(user_id)
        is_cofounder = staff_data and staff_data['role'] == '2'
        
        if is_founder:
            user_type = "üëë FUNDADOR"
        elif is_cofounder:
            user_type = "üíé CO-FUNDADOR"
        else:
            user_type = "üíé PREMIUM"

        response = f"üî• **GATES SYSTEM ULTRA** üî•\n"
        response += f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n"
        response += f"üéØ **Acceso:** {user_type}\n"
        response += f"üí∞ **Cr√©ditos:** {user_data['credits']}\n"
        response += f"üí≥ **Costo por gate:** 5 cr√©ditos\n"
        response += f"‚ö° **Efectividad:** 8-25% (Realista)\n\n"
        response += f"üí° **Selecciona el gate que deseas usar:**"

        await query.edit_message_text(
            response,
            reply_markup=keyboard,
            parse_mode=ParseMode.MARKDOWN
        )
        return

    # Procesar selecci√≥n de gate espec√≠fico
    gate_types = {
        'gate_stripe': ('Stripe Gate', 'üîµ'),
        'gate_amazon': ('Amazon Gate', 'üü†'),
        'gate_paypal': ('PayPal Gate', 'üî¥'),
        'gate_ayden': ('Ayden Gate', 'üü°'),
        'gate_auth': ('Auth Gate', 'üü¢'),
        'gate_ccn': ('CCN Charge', '‚ö´')
    }

    if query.data in gate_types:
        # VERIFICAR PERMISOS AL SELECCIONAR GATE
        if not gate_system.is_authorized(user_id):
            await query.edit_message_text(
                "üö´ **ACCESO RESTRINGIDO** üö´\n\n"
                "üíé **¬°Necesitas ser Premium, Fundador o Co-Fundador para usar los Gates!**\n\n"
                "üîê **Para obtener acceso premium:**\n"
                "‚Ä¢ üí≥ Contacta a @SteveCHBll\n"
                "‚Ä¢ üîë Usa `/apply_key [c√≥digo]` si tienes una clave\n\n"
                "‚ö° **Beneficios Premium:**\n"
                "‚Ä¢ ‚úÖ Acceso completo a todos los gates\n"
                "‚Ä¢ ‚úÖ Efectividad realista (8-25%)\n"
                "‚Ä¢ ‚úÖ Procesamiento de m√∫ltiples tarjetas\n"
                "‚Ä¢ ‚úÖ Soporte prioritario\n"
                "‚Ä¢ ‚úÖ Control anti-rate limit\n\n"
                "üéØ **¬°Invierte en Premium y obt√©n resultados reales!**",
                parse_mode=ParseMode.MARKDOWN
            )
            return

        gate_name, gate_emoji = gate_types[query.data]

        # Crear sesi√≥n para este usuario (solo si est√° autorizado)
        gate_system.active_sessions[user_id] = {
            'gate_type': query.data,
            'gate_name': gate_name,
            'gate_emoji': gate_emoji,
            'timestamp': datetime.now()
        }

        response = f"{gate_emoji} **{gate_name.upper()}** {gate_emoji}\n"
        response += f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n"
        response += f"üéØ **Estado:** üü¢ Online\n"
        response += f"üí∞ **Precio:** 5 cr√©ditos por tarjeta\n"
        response += f"üìä **Plan:** Premium Access\n"
        response += f"‚ö° **Comando:** /am\n\n"
        response += f"üí≥ **Env√≠a tu tarjeta en formato:**\n"
        response += f"`4532123456781234|12|25|123`\n\n"
        response += f"üîÑ **El gate procesar√° autom√°ticamente**\n"
        response += f"‚è±Ô∏è **Tiempo estimado:** 2-5 segundos\n"
        response += f"‚ö†Ô∏è **Efectividad REALISTA garantizada**\n\n"
        response += f"üí° **Tip:** Usa tarjetas con BIN conocido"

        back_keyboard = [[InlineKeyboardButton("üîô Volver al men√∫", callback_data='gates_back')]]

        await query.edit_message_text(
            response,
            reply_markup=InlineKeyboardMarkup(back_keyboard),
            parse_mode=ParseMode.MARKDOWN
        )

async def process_gate_card(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Procesar m√∫ltiples tarjetas enviadas cuando hay sesi√≥n activa - CON CONTROL DE RATE LIMITING"""
    global gate_system
    user_id = str(update.effective_user.id)

    # VERIFICAR PERMISOS ANTES DE PROCESAR
    if not gate_system.is_authorized(user_id):
        await update.message.reply_text(
            "üö´ **PROCESAMIENTO BLOQUEADO** üö´\n\n"
            "üíé **Solo usuarios Premium, Fundadores y Co-Fundadores pueden procesar tarjetas**\n\n"
            "üî• **¬øPor qu√© ser Premium?**\n"
            "‚Ä¢ üí≥ Acceso real a gates de pago\n"
            "‚Ä¢ üéØ Efectividad comprobada (8-25%)\n"
            "‚Ä¢ üí∞ Recupera la inversi√≥n con pocas tarjetas LIVE\n"
            "‚Ä¢ ‚ö° Control anti-rate limit avanzado\n\n"
            "üìû **Contacta a @SteveCHBll para ser Premium**",
            parse_mode=ParseMode.MARKDOWN
        )
        return

    # Verificar si hay sesi√≥n activa
    if user_id not in gate_system.active_sessions:
        return

    session = gate_system.active_sessions[user_id]
    message_text = update.message.text.strip()

    # Detectar m√∫ltiples tarjetas en el mensaje
    import re
    card_pattern = r'\b\d{13,19}\|\d{1,2}\|\d{2,4}\|\d{3,4}\b'
    cards_found = re.findall(card_pattern, message_text)

    if not cards_found:
        await update.message.reply_text(
            "‚ùå **Formato inv√°lido**\n\n"
            "üí° **Formato correcto:**\n"
            "`4532123456781234|12|25|123`\n\n"
            "üìã **Puedes enviar m√∫ltiples tarjetas separadas por l√≠neas**",
            parse_mode=ParseMode.MARKDOWN)
        return

    # Verificar l√≠mites seg√∫n nivel de usuario
    is_founder = db.is_founder(user_id)
    staff_data = db.get_staff_role(user_id)
    is_cofounder = staff_data and staff_data['role'] == '2'
    user_data = db.get_user(user_id)
    is_premium = user_data.get('premium', False)

    # Establecer l√≠mites
    if is_founder:
        max_cards = 15  # Fundadores m√°s tarjetas
        user_type = "üëë FUNDADOR"
    elif is_cofounder:
        max_cards = 12  # Co-fundadores tambi√©n m√°s
        user_type = "üíé CO-FUNDADOR"
    elif is_premium:
        max_cards = 8   # Premium moderado
        user_type = "üíé PREMIUM"
    else:
        await update.message.reply_text("‚ùå Acceso denegado")
        return

    # Verificar l√≠mite de tarjetas
    if len(cards_found) > max_cards:
        await update.message.reply_text(
            f"‚ùå **L√çMITE EXCEDIDO** ‚ùå\n\n"
            f"üéØ **Tu nivel:** {user_type}\n"
            f"üìä **L√≠mite m√°ximo:** {max_cards} tarjetas\n"
            f"üì§ **Enviaste:** {len(cards_found)} tarjetas\n\n"
            f"üí° **Env√≠a m√°ximo {max_cards} tarjetas por vez**",
            parse_mode=ParseMode.MARKDOWN)
        return

    # Verificar cr√©ditos (5 por tarjeta)
    total_cost = len(cards_found) * 5
    if user_data['credits'] < total_cost:
        await update.message.reply_text(
            f"‚ùå **CR√âDITOS INSUFICIENTES** ‚ùå\n\n"
            f"üí∞ **Necesitas:** {total_cost} cr√©ditos\n"
            f"üí≥ **Tienes:** {user_data['credits']} cr√©ditos\n"
            f"üìä **Costo:** 5 cr√©ditos por tarjeta\n"
            f"üéØ **Tarjetas:** {len(cards_found)}\n\n"
            f"üí° Usa `/bonus` para obtener cr√©ditos gratis",
            parse_mode=ParseMode.MARKDOWN)
        return

    # Descontar cr√©ditos
    db.update_user(user_id, {'credits': user_data['credits'] - total_cost})

    # Procesar cada tarjeta individualmente CON CONTROL DE RATE LIMITING
    for i, card_data in enumerate(cards_found, 1):

        # Mensaje de procesamiento
        processing_msg = await update.message.reply_text(
            f"{session['gate_emoji']} **PROCESANDO {session['gate_name'].upper()}** {session['gate_emoji']}\n\n"
            f"üí≥ **Tarjeta {i}/{len(cards_found)}:** {card_data[:4]}****{card_data[-4:]}\n"
            f"‚è≥ **Estado:** Conectando al gateway...\n"
            f"üîÑ **Progreso:** [‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 20%",
            parse_mode=ParseMode.MARKDOWN
        )

        # CONTROLAR RATE LIMITING - Esperar entre mensajes
        if i > 1:
            await asyncio.sleep(3)  # Pausa entre tarjetas

        # Simular progreso CON CONTROL DE RATE LIMITING
        await asyncio.sleep(1.5)
        await gate_system.safe_edit_message(
            processing_msg,
            f"{session['gate_emoji']} **PROCESANDO {session['gate_name'].upper()}** {session['gate_emoji']}\n\n"
            f"üí≥ **Tarjeta {i}/{len(cards_found)}:** {card_data[:4]}****{card_data[-4:]}\n"
            f"‚è≥ **Estado:** Verificando datos...\n"
            f"üîÑ **Progreso:** [‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 40%"
        )

        await asyncio.sleep(1.5)
        await gate_system.safe_edit_message(
            processing_msg,
            f"{session['gate_emoji']} **PROCESANDO {session['gate_name'].upper()}** {session['gate_emoji']}\n\n"
            f"üí≥ **Tarjeta {i}/{len(cards_found)}:** {card_data[:4]}****{card_data[-4:]}\n"
            f"‚è≥ **Estado:** Procesando con gateway...\n"
            f"üîÑ **Progreso:** [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë] 60%"
        )

        # Procesar seg√∫n el tipo de gate
        gate_type = session['gate_type']
        if gate_type == 'gate_stripe':
            result = await gate_system.process_stripe_gate(card_data)
        elif gate_type == 'gate_amazon':
            result = await gate_system.process_amazon_gate(card_data)
        elif gate_type == 'gate_paypal':
            result = await gate_system.process_paypal_gate(card_data)
        elif gate_type == 'gate_ayden':
            result = await gate_system.process_ayden_gate(card_data)
        elif gate_type == 'gate_ccn':
            result = await gate_system.process_ccn_charge(card_data)
        else:
            result = await gate_system.process_auth_gate(card_data)

        # Mostrar resultado final
        status_emoji = "‚úÖ" if result['success'] else "‚ùå"

        final_response = f"{session['gate_emoji']} **{session['gate_name'].upper()} RESULTADO** {session['gate_emoji']}\n"
        final_response += f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n"
        final_response += f"üí≥ **Tarjeta:** {card_data}\n"
        final_response += f"üéØ **Estado:** {result['status']} {status_emoji}\n"
        final_response += f"üì° **Gateway:** {result['gateway']}\n"
        final_response += f"üí∞ **Monto:** {result.get('amount', '$0.00')}\n"
        final_response += f"üìù **Respuesta:** {result['message']}\n"
        final_response += f"‚è∞ **Tiempo:** {datetime.now().strftime('%H:%M:%S')}\n"
        final_response += f"üë§ **Procesado por:** @{update.effective_user.username or update.effective_user.first_name}\n"
        final_response += f"üî¢ **Tarjeta {i} de {len(cards_found)}**\n\n"
        final_response += f"üí∞ **Cr√©ditos restantes:** {user_data['credits'] - total_cost}"

        keyboard = [[InlineKeyboardButton("üîÑ Procesar otra", callback_data=gate_type),
                    InlineKeyboardButton("üîô Men√∫ principal", callback_data='gates_back')]]

        await gate_system.safe_edit_message(
            processing_msg,
            final_response,
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

        # Pausa adicional entre tarjetas para evitar rate limiting
        if i < len(cards_found):
            await asyncio.sleep(2)

    # Limpiar sesi√≥n al final
    if user_id in gate_system.active_sessions:
        del gate_system.active_sessions[user_id]
